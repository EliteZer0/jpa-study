# 07. 고급 매핑

## 7-1 상속 관계 매핑

객체지향 언어의 `상속` ≒ `슈퍼타입 서브타입 관계` 모델링 기법

슈퍼타입 서브타입 논리 모델을 실제 물리 모델인 테이블로 구현할 때는 3가지 방법을 선택할 수 있다.

- 각각의 테이블로 변환 (= 조인 전략)
- 통합 테이블로 변환 (= 단일 테이블 전략)
- 서브타입 테이블로 변환 (= 테이블 전략)

### 조인 전략

조인 전략은 엔티티 각각을 모두 테이블로 만들고 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용한다.
테이블은 타입의 개념이 없으므로 `DTYPE` 컬럼과 같이 타입을 구분하는 컬럼을 추가해야 한다.

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
// 상속 매핑은 부모 클래스에 `@Inheritance`를 사용해야 한다.
// 그리고 매핑 전략은 `InheritanceType.JOINED`를 사용하면 된다.
@DiscriminatorColumn(name = "DTYPE")
// 엔티티를 저장할 때 구분 컬럼에 입력할 값을 지정한다.

public abstract class Item {
    @Id @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    private String name;
    private int price;
}

@Entity
@DiscriminatorValue("A")
// 만약 아티스트 엔티티를 저장하면 구분 컬림인 DTYPE 에 A 가 저장된다.
public class Album extends Item { 
    private String artist;
}

@Entity
@DiscriminatorValue("M")
// 만약 영화 엔티티를 저장하면 구분 컬림인 DTYPE 에 M 이 저장된다.
public class Movie extends Item {
    private String director;
    private String actor;
}  

@Entity
@DiscriminatorValue("B")
// 만약 책 엔티티를 저장하면 구분 컬림인 DTYPE 에 B 가 저장된다.
@PrimaryKeyJoinColumn(name = "BOOK_ID")
// name 속성을 통해 자식 테이블의 기본 키 컬럼명을 지정한다.
// name 속성을 사용하지 않으면 부모 테이블의 ID 컬럼명을 그대로 사용한다.
public class Book extends Item { 
    private String author;
    private String isbn;
}
```

**장점**
- 테이블이 정규화된다.
- 외래 키 참조 무결성 제약 조건을 활용할 수 있다.
- 저장 공간을 효율적으로 사용한다.  

**단점**
- 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있다.
- 조회 쿼리가 복잡하다.
- 데이터를 등록할 때 `INSERT SQL`을 두 번 실행한다. 

**특징**
- JPA 표준 명세는 구분 컬럼을 사용하도록 하지만, 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼이 없이도 동작한다.

#### @DiscriminatorColumn과 @DiscriminatorValue의 역할

- **@DiscriminatorColumn**: 부모 클래스에 지정하며, 엔티티를 구분하기 위한 컬럼을 정의. 주로 DTYPE이라는 이름으로 사용되며, 어떤 자식 엔티티인지 구분하는 역할.
- **@DiscriminatorValue**: 자식 클래스에 지정하며, 구분 컬럼에 저장될 값을 정의. 예를 들어, Album 엔티티에 @DiscriminatorValue("A")를 지정하면 해당 엔티티가 저장될 때 구분 컬럼에 'A'가 저장.

#### @PrimaryKeyJoinColumn 어노테이션의 역할

`@PrimaryKeyJoinColumn`은 조인 전략에서 자식 테이블의 기본 키 컬럼명을 지정하는 역할.
기본적으로는 부모 테이블의 ID 컬럼명을 그대로 사용하지만, 이 어노테이션을 통해 다른 이름으로 변경할 수 있다.

사용 시나리오:
1. 자식 테이블의 기본 키/외래 키 컬럼명을 명시적으로 제어해야 할 때
2. 레거시 데이터베이스와 매핑할 때 기존 컬럼명을 유지해야 하는 경우
3. 여러 상속 계층에서 명확한 컬럼명 규칙을 적용하고자 할 때

#### InheritanceType.JOINED 전략에서 INSERT SQL이 두 번 실행되는 과정

조인 전략에서 자식 엔티티(예: Album)를 저장할 때:

먼저 부모 테이블(ITEM)에 공통 속성(id, name, price)을 저장하는 INSERT SQL이 실행.
```sql
INSERT INTO ITEM (ITEM_ID, NAME, PRICE, DTYPE) VALUES (?, ?, ?, 'A')
```

그 다음, 자식 테이블(ALBUM)에 고유 속성(artist)과 식별자를 저장하는 두 번째 INSERT SQL이 실행
```sql
INSERT INTO ALBUM (ARTIST, ITEM_ID) VALUES (?, ?)
```

이러한 두 번의 INSERT 과정은 트랜잭션으로 관리되어, 둘 중 하나라도 실패하면 롤백된다.
이는 데이터 무결성을 보장하지만, 단일 테이블 전략에 비해 약간의 성능 오버헤드가 발생할 수 있다.

#### 조인 전략에서 성능 최적화 방법
1. 적절한 인덱스 설정 (특히 자식 테이블의 외래 키)
2. 페치 조인(fetch join)을 활용한 N+1 문제 해결
3. 필요한 엔티티 타입만 조회하도록 JPQL 쿼리 작성
4. @BatchSize 또는 @Fetch(FetchMode.SUBSELECT)를 활용한 일괄 로딩
5. 자주 사용되는 조회 패턴에 대해 네이티브 SQL 쿼리나 스토어드 프로시저 활용
6. 읽기 전용 조회의 경우 두 테이블을 조인한 뷰(View)를 생성하여 활용

### 단일 테이블 전략

단일 테이블 전략은 테이블을 하나만 사용하고, 구분 컬럼인 `DTYPE` 으로 어떤 자식 데이터가 저장되었는지 구분한다.

```java
@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE) // 단일 테이블 전략 사용 지정정
@DiscriminatorColumn(name = "DTYPE")
public abstract class Item {
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    private String name;
    private int price;
}

@Entity
@DiscriminatorValue("A")
public class Album extends Item {
	private String artist;
        ...

}  

@Entity
@DiscriminatorValue("M")
public class Movie extends Item {

        ...

}

@Entity
@DiscriminatorValue("B")
public class Book extends Item {
        ...
}

```

**장점**
- 조인이 필요 없으므로 일반적으로 조회 성능이 빠르다.
- 조회 쿼리가 단순하다.

**단점**
- 자식 엔티티가 매핑한 컬럼은 모두 `null`을 허용해야 한다.
	- 단일 테이블 전략에서는 모든 자식 엔티티의 속성이 하나의 테이블에 통합되기 때문에, 특정 자식 엔티티에만 존재하는 속성은 다른 타입의 엔티티에서는 값이 없다.
	- 예를 들어, `Album`의 `artist` 속성은 `Movie`나 `Book` 타입의 데이터에는 해당되지 않으므로 `NULL`이 될 수밖에 없다.
- 단일 테이블에 모든 것을 저장하므로 테이블이 커질 수 있다. 그러므로 상황에 따라서는 조회 성능이 오히려 느려질 수 있다.

**특징**
- 구분 컬럼을 꼭 사용해야 한다. 따라서 `@DiscriminatorColumn`을 꼭 설정해야 한다.
- `@DiscriminatorValue` 를 지정하지 않으면 기본으로 엔티티 이름을 사용한다.

### 구현 클래스마다 테이블 전략

자식 엔티티마다 테이블을 만드는 전략이다.
자식 테이블 각각에 필요한 컬럼이 모두 있다.
***일반적으로 추천하지 않는 전략이다.***

```java
@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class Item {
    @Id
    @GeneratedValue
    @Column(name = "ITEM_ID")
    private Long id;
    private String name;
    private int price;
}

@Entity
public class Album extends Item {
        ...
}  

public class Movie extends Item {
        ...
}

@Entity
public class Book extends Item {
        ...
}
```

**장점**
- 서브 타입을 구분해서 처리할 때 효과적이다.
- `not null` 제약 조건을 사용할 수 있다.

**단점**
- 여러 자식 테이블을 함께 조회할 때 성능이 느리다 (`SQL`에 `UNION`을 사용해야 한다).
- 자식 테이블을 통합해서 쿼리하기 어렵다.

**특징**
- 구분 컬럼을 사용하지 않는다.

#### 구현 클래스마다 테이블 전략이 일반적으로 추천되지 않는 이유
1. 여러 자식 테이블을 함께 조회할 때 UNION 연산이 필요해 성능이 저하된다.
2. 부모 타입으로 조회할 때 모든 테이블을 뒤져야 하므로 성능이 매우 비효율적이다.
3. 자식 테이블간 공통 컬럼이 중복되어 데이터 일관성 관리가 어렵다.
4. 테이블 간 통합 제약조건을 적용하기 어렵다.
5. 스키마 변경 시 모든 테이블을 수정해야 하므로 유지보수가 복잡하다.

### 정리

**조인 전략**
- **장점**: 테이블이 정규화되고, 외래 키 참조 무결성 제약조건을 활용할 수 있으며, 저장 공간을 효율적으로 사용한다.
- **단점**: 조회 시 조인 연산이 필요하여 성능이 저하될 수 있고, 쿼리가 복잡해지며, 데이터 등록 시 INSERT SQL이 두 번 실행된다.

**단일 테이블 전략**
- **장점**: 조인이 필요 없어서 일반적으로 조회 성능이 빠르고, 조회 쿼리가 단순하다.
- **단점**: 자식 엔티티 필드들이 모두 NULL을 허용해야 하며, 테이블이 커져 오히려 성능이 저하될 수 있다.

**구현 클래스마다 테이블 전략**
- **장점**: 서브타입을 명확히 구분할 수 있고, NOT NULL 제약조건을 사용할 수 있다.
- **단점**: 여러 자식 테이블을 함께 조회할 때 UNION을 사용해야 해서 성능이 떨어지고, 통합 쿼리가 어렵다.

#### 상속 관계 매핑에서 LAZY 로딩과 EAGER 로딩 선택이 미치는 영향
- **LAZY 로딩**: 자식 엔티티는 실제로 접근할 때만 로딩된다. 조인 전략에서는 부모 엔티티만 먼저 조회하고 자식 정보가 필요할 때 추가 쿼리가 발생한다.
- **EAGER 로딩**: 부모 엔티티 조회 시 자식 엔티티도 함께 로딩된다. 조인 전략에서는 항상 조인을 통해 한 번에 데이터를 가져온다.

EAGER 로딩은 필요하지 않은 자식 엔티티까지 항상 로딩하는 단점이 있어, 기본적으로 LAZY 로딩을 사용하고, 자주 함께 사용되는 엔티티는 필요에 따라 페치 조인으로 최적화하는 것이 일반적인 접근법이다.

하지만 EAGER 로딩이 완전히 배제되는 것은 아니며, 다음과 같은 상황에서는 유용할 수 있다.

-  **항상 함께 사용되는 관계**: 부모 엔티티와 자식 엔티티가 거의 항상 함께 사용되는 경우, EAGER 로딩이 N+1 문제를 방지하면서 코드를 단순하게 유지할 수 있다.
- **데이터 양이 적은 경우**: 자식 엔티티의 데이터가 매우 적고 단순할 때, EAGER 로딩으로 인한 성능 영향이 미미하다.
- **복잡한 비즈니스 로직 간소화**: 항상 함께 처리되어야 하는 복잡한 비즈니스 로직에서는 EAGER 로딩이 코드를 단순화할 수 있다.
- **단방향 연관관계**: 특히 @ManyToOne, @OneToOne과 같은 단방향 연관관계에서는 EAGER가 기본 전략으로 설정되어 있다.

#### 실무에서 상속 관계 매핑을 설계할 때 고려해야 할 핵심 요소
1. **데이터 특성**: 엔티티 간 공통 속성과 고유 속성의 비율
2. **조회 패턴**: 부모 타입으로 조회하는 빈도 vs 특정 자식 타입만 조회하는 빈도
3. **데이터 양**: 전체 데이터 크기와 각 타입별 데이터 비율
4. **성능 요구사항**: 조회 성능 vs 데이터 일관성의 우선순위
5. **비즈니스 변경 가능성**: 향후 서브타입 추가나 속성 변경 가능성
6. **레거시 시스템 제약**: 기존 데이터베이스 스키마와의 통합 필요성
7. **트랜잭션 특성**: 데이터 삽입/수정 빈도와 패턴

일반적으로 정규화와 무결성이 중요하면 조인 전략, 조회 성능이 최우선이면 단일 테이블 전략을 선택하는 것이 적합하다.

## 7-2 @MappedSuperclass

부모 클래스는 테이블과 매핑하지 않고 부모 클래스를 상속 받는 자식 클래스에게 매핑 정보만 제공하고 싶은 경우 해당 어노테이션을 사용한다.
@MappedSuperclass는 추상 클래스와 비슷하다.
실제 테이블과 매핑없이 단순히 매핑 정보를 뽑아서 재사용할 목적으로 사용한다.

```java
@MappedSuperclass
public abstract class BaseEntity {
    @Id
    @GeneratedValue
    private Long id;
	private String name;
}

@Entity
public class Member extends BaseEntity {
    // ID 상속
    // NAME 상속
    private String email;
}

@Entity
public class Seller extends BaseEntity {
    // ID 상속
    // NAME 상속
    private String shopName;
}

```

**@MappedSuperclass의 특징**
- 테이블과 매핑되지 않고 자식 클레스에 엔티티의 매핑 정보를 상속하기 위해 사용한다.
- 해당 어노테이션이 붙은 클래스는 엔티티가 아니다.
- 추상 클래스로 만드는 것을 권장한다.
	- **개념적 명확성**
		- @MappedSuperclass는 그 자체로 엔티티가 아니라 공통 매핑 정보를 자식 클래스에게 상속하기 위한 용도이다.
		- 추상 클래스로 선언함으로써 이 클래스가 직접 인스턴스화될 수 없고 상속을 위한 것임을 명확히 할 수 있다.
	- **의도하지 않은 사용 방지**
		- 추상 클래스로 선언하면 개발자가 실수로 이 클래스의 인스턴스를 직접 생성하는 것을 컴파일 시점에 방지할 수 있다.
		- @MappedSuperclass는 테이블에 매핑되지 않기 때문에 인스턴스를 직접 생성하여 사용하면 의도치 않은 오류가 발생할 수 있다.
	- **설계 의도 표현**
		- 추상 클래스는 "이 클래스는 확장되어야 한다"는 설계 의도를 명확히 표현한다. 
		- MappedSuperclass의 목적이 바로 상속을 통한 코드 재사용이므로, 추상 클래스로 선언하는 것이 그 의도에 부합한다.
	- **불완전한 엔티티 표현**
		- 대부분의 경우 @MappedSuperclass는 ID나 특정 필드가 없는 불완전한 엔티티인 경우가 많다.
		- 추상 클래스로 만들면 이러한 불완전성을 명시적으로 나타낼 수 있다.

### 🚫 JPA 상속 구조에서 필드 중복 실수

<details>
<summary>BaseEntity와 Member 클래스의 필드 중복 문제</summary>

### 문제 상황

BaseEntity 클래스에서 이미 `deleted` 필드를 정의했음에도 불구하고, 이를 상속한 Member 클래스에서 동일한 필드를 다시 정의.

~~실제로 이 부분에 대한 코드리뷰가 구두로 진행되어 반영을 했었는데 특정 시점에서 롤백되며 체크를 하지 못한 것으로 추정됨~~


```java
// BaseEntity 클래스
@Getter
@MappedSuperclass
@EnableJpaAuditing
@EntityListeners(AuditingEntityListener.class)
public class BaseEntity {
    @CreatedDate
    @Column(name = "created_at", updatable = false, nullable = false)
    private Timestamp createdAt;
    @LastModifiedDate
    @Column(name = "modified_at", nullable = false)
    private Timestamp modifiedAt;
    @Column(nullable = false)
    @ColumnDefault(value = "false")
    private boolean deleted = false;
    
    public void delete() {
        this.deleted = true;
    }
}

// Member 클래스
@Entity
@Table(name = "member")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString
public class Member extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ... 다른 필드들 ...
    
    // 문제: BaseEntity에 이미 존재하는 필드를 중복 정의
    private boolean deleted = false;
    
    // 문제: 부모 클래스의 메서드를 불필요하게 오버라이드
    @Override
    public void delete() {
        super.delete();
        this.deleted = true;
    }
}
```

### 발생 가능한 문제점

1. **데이터 불일치**: Member 객체의 `deleted` 상태를 변경할 때, 어떤 필드가 실제로 업데이트 될지 혼란스러울 수 있다.
    
2. **쿼리 혼란**: JPA가 생성하는 쿼리에서 어떤 `deleted` 컬럼을 참조할지 예측하기 어려워진다.
    
3. **소프트 삭제 기능 오작동**: 소프트 삭제 기능이 의도한 대로 작동하지 않을 수 있다.
    
4. **유지보수 어려움**: 코드를 유지보수하는 개발자가 어떤 `deleted` 필드를 사용해야 하는지 혼란스러울 수 있다.
    
### 해결 방법

Member 클래스에서 중복된 `deleted` 필드를 제거한다:

```java
@Entity
@Table(name = "member")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@ToString
public class Member extends BaseEntity {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    // ... 다른 필드들 ...
    
    // deleted 필드는 BaseEntity에서 상속받으므로 제거
    
    // 회원 삭제 - 단순히 상위 클래스의 메서드 호출
    @Override
    public void delete() {
        super.delete(); // 이것만으로 충분함
    }
}
```

### 추가 개선 사항

1. **BaseEntity를 추상 클래스로 선언**: BaseEntity는 공통 필드와 기능만 제공하는 클래스로, 직접 인스턴스화될 필요가 없으므로 추상 클래스로 선언하는 것이 좋다.
    
    ```java
    @Getter
    @MappedSuperclass
    @EnableJpaAuditing
    @EntityListeners(AuditingEntityListener.class)
    public abstract class BaseEntity {
        // ... 필드 및 메서드 ...
    }
    ```

2. **상속 구조 검토**: 상속 구조를 사용할 때는 부모 클래스의 필드와 메서드를 명확히 이해하고 사용해야 한다.
    
3. **코드 리뷰 강화**: 이러한 중복 문제를 조기에 발견할 수 있도록 코드 리뷰 프로세스를 강화한다.
    
4. **테스트 케이스 추가**: 소프트 삭제 기능이 제대로 작동하는지 확인하는 테스트 케이스를 추가한다.
    
5. **주석 추가**: BaseEntity의 기능을 명확히 설명하는 주석을 추가하여 다른 개발자들이 실수하지 않도록 한다.

6. **정적 코드 분석 도구 활용**: SonarQube, PMD와 같은 도구를 사용하여 이러한 잠재적 문제를 자동으로 감지한다.
</details>

## 7-3 복합 키와 식별 관계 매핑
## 7-4 조인 테이블
## 7-5 엔티티 하나에 여러 테이블 매핑
  