# 7. 고급매핑

- 상속 관계 매핑
- @MappedSuperclass
- 복합 키와 식별 관계 매핑
- 조인 테이블
- 엔티티 하나에 여러 테이블 매핑


## 7.1 상속 관계 매핑
관계형 데이터베이스에서 **슈퍼 타입 서브타입 관계** 라는 모델링 기법이 상속 개념과 가장 유사함 <br>
ORM에서 이야기하는 상속 관계 매피은 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타입 관계를 매핑하는 것 <br>
![image](https://github.com/user-attachments/assets/b57e3f92-8bd5-4a7a-b5b5-a67958ba0f7f)
![image](https://github.com/user-attachments/assets/432c81b7-1041-4f51-ba74-e6d716ca6a1a)


- 테이블로 구현하기 위한 3가지 방법
1. 각각의 테이블로 변환 : 각각을 모두 테이블로 만들고 조회 -> `조인 전략`
2. 통합 테이블로 변환 : 테이블을 하나만 사용해 통합 -> `단일 테이블 전략`
3. 서브타입 테이블로 변환 : 서브 타입마다 하나의 테이블을 생성 -> `구현 클래스마다 테이블 전략`

<br>

### 7.1.1 조인 전략
> 엔티티 각각을 모두 테이블로 만들고, 자식 테이블이 부모 테이블의 기본 키를 받아서 기본 키 + 외래 키로 사용하는 전략

- 조회할 때 조인을 자주 사용함
- 타입을 구분하는 컬럼을 추가해야 함 (테이블은 타입의 개념이 없기 때문에)
![image](https://github.com/user-attachments/assets/2c2717a8-5800-4346-b797-d2ea03d57d22)
![image](https://github.com/user-attachments/assets/0a4f448c-3cd0-478b-9611-3e18b3334fe9)
1. `@Inheritance(strategy = IngeritanceType.JOINED)`
   - 상속 매핑은 부모 클래스에 `@Inheritance` 사용
   -  조인 전략을 사용하므로 `InheritanceType.JOINED` 사용
2. `@DiscriminatorColumn(name = "DTYPE")`
   - 부모 클래스에 구분 컬럼을 지정
   - 이 컬럼으로 저장된 자식 테이블을 구분할 수 있음
   - 기본값이 DTYPE 이므로 `@DiscriminatorColumn` 으로 줄여 사용해도 됨
3. `@DiscriminatorValue("M")`
   - 엔티티를 저장할 때 구분 컬럼에 입력할 값 지정
   - EX: 영화 엔티티를 저장하면 구분 컬럼인 DTYPE에 값 'M'이 저장됨

![image](https://github.com/user-attachments/assets/f12d29c0-8881-4f5d-a9d6-4e7209c8890f)
- 기본값으로 자식 테이블은 부모 테이블의 ID 컬럼명을 그대로 사용하지만, 변경하고 싶다면
- `@PrimaryKeyJoinColumn`을 사용하자!

<br>

### <정리>

**장점**
- 테이블이 정규화 됨
- 외래 키 참조 무결성 제약조건을 활용할 수 있음
- 저장공간을 효율적으로 사용함

**단점**
- 조회할 때 조인이 많이 사용되므로 성능이 저하될 수 있음
- 조회 쿼리가 복잡함
- 데이터를 등록할 INSERT SQL을 두 번 실행함

**특징**
- JPA 표준 명세는 구분 컬럼을 사용하도록 하지만 하이버네이트를 포함한 몇몇 구현체는 구분 컬럼(@DiscriminatorColumn) 없이도 동작함

**관련 어노테이션**
- @PrimaryKeyJoinColumn, @DiscriminatorColumn, @DiscriminatorValue

<br>

### 7.1.2 단일 테이블 전략
> 이름 그대로 테이블을 하나만 사용하며, 구분 컬럼(DTYPE)으로 어떤 자식 데이터가 저장되었는지 구분함

- 조회할 때 조인을 사용하지 않으므로 일반적으로 가장 빠름!
- 자식 엔티티가 매핑한 컬럼은 모두 **null을 허용** 해야함 <br>
![image](https://github.com/user-attachments/assets/70c9a330-a3e5-470e-b4b4-813d701fd607)

![image](https://github.com/user-attachments/assets/a94a030b-2717-4613-b76f-2a9b40324d14)
![image](https://github.com/user-attachments/assets/a6a4e45d-0b4e-4bc9-9304-fff5a94e0919)

1. `IngeritanceType.SINGLE_TABLE`로 지정하면 단일 테이블 전략 사용
2. 테이블 하나에 모든 것을 통합하므로 구분 컬럼을 **필수**로 사용해야 함

### <정리>

**장점**
- 조인이 필요 없음 -> 일반적으로 조회 성능 빠름
- 조회 쿼리 단순

**단점**
- 자식 엔티티가 매핑한 컬럼은 모두 null을 허용해야 함
- 단일 테이블에 모든 것을 저장 -> 테이블이 커질 수 있고, 상황에 따라서 조회 성능 하락

**특징**
- 구분 컬럼을 꼭 사용해야 함 => `@DiscriminatorColumn` 필수
- `@DiscriminatorValue`를 지정하지 않으면 엔티티 이름을 사용함 (예: Movie, Album, Book)
  

<br>

### 7.1.3 구현 클래스마다 테이블 전략
> 자식 엔티티마다 테이블을 생성하고, 자식 테이블 각각에 필요한 컬럼이 모두 있음

![image](https://github.com/user-attachments/assets/d0f5a05c-fa08-4d19-9c8c-e41edeac133e)
![image](https://github.com/user-attachments/assets/a77d5a14-b8f6-4b84-8358-e1cbe7e12b29)

1. `InheritanceType.TABLE_PER_CLASS`를 선택하면 구현 클래스마다 테이블 전략을 사용
2. 자식 엔티티마다 테이블을 생성
3. **일반적으로 추천하지 않음**

### <정리>

**장점**
- 서브 타입을 구분해서 처리할 때 효과적
- not null 제약 조건 사용 가능

**단점**
- 여러 자식 테이블을 함께 조회할 때 성능이 느리다(SQL에 UNION을 사용해야 함)
- 자식 테이블을 통합해서 쿼리하기 어려움

**특징**
- 구분 컬럼을 사용하지 않음

**추천하지 않는 이유**

