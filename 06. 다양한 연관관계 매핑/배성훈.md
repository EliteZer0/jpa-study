# 5장에서...

엔티티의 연관간계를 매핑할 때는 다음 3가지를 고려해야 한다.

1. 다중성 - 다대일, 일대다, 일대일, 다대다
2. 단방향, 양방향 - 한쪽만 참조하면 단방향, 서로 참조하면 양방향
3. 연관관계의 주인 
   - DB는 외래 키 하나로 두 테이블이 연관관계를 맺음. 
   - 연관관계의 주인은 외래 키를 가진 쪽이다
   - mappedBy는 내가 주인이 아님을 표시하는 것
   - DB 수정은 주인 엔티티에서 해야 한다

<br/><br/>

# 6.1 다대일

- 결론부터 말하자면... 사실 JPA 연관관계 매핑의 기본은 다대일을 기본으로 고려해야 한다.
- 그리고 다대일 + 양방향이면 거의 모든 요구사항을 커버할 수 있다고도 생각함
- 하지만 다른 연관관계 매핑도 알아는 둬야하니 차근차근 알아보자!

## 다대일 단방향(N:1)

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    
    private String username;
    
    @ManyToOne              // 다대일 관계
    @JoinColumn(name = "team_id")  // FK 컬럼명
    private Team team;      // 팀 참조
}

@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    
    private String name;
    
    // Team은 Member를 모름 (단방향)
}
```

- 즉, Member -> Team 으로만 접근이 가능함

<br/>

## 다대일 양방향(N:1, 1:N)

```java
@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    
    private String username;
    
    @ManyToOne              
    @JoinColumn(name = "team_id")  
    private Team team;      // 다대일 쪽이 연관관계의 주인
    
    public void setTeam(Team team) {
        this.team = team;
        if (!team.getMembers().contains(this)) {
            team.getMembers().add(this);
        }
    }
}

@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "team")  // Member의 team 필드에 의해 매핑됨
    private List<Member> members = new ArrayList<>();
}
```

- 주인은 무조건 외래 키가 있는 쪽으로 정해야 하기도 하고, 정해지기도 함
- 이는 DB 설계상 '다' 쪽이 항상 FK를 가지기 때문이다
- 직관적으로 따져봤을 때도... 멤버가 어떤 팀에 있는지를 따지는게 훨씬 자연스럽다!

<br/>

- ex) **너 1팀이야?** vs **1팀에 너 있어?**
- 뭐가 더 자연스러운지 판단해보세요 :)

<br/><br/>

# 6.2 일대다

- 다대일의 반대 개념이다.
- 누가 이 관계를 관리하느냐! 를 중점으로 보면 된다.
- 아까 다대일에서는 '다' 쪽이 연관관계의 주인이었음
- 그러나 일대다에서는 '일' 쪽이 연관관계의 주인이 된다.
- ex)
  - 멤버가 주인: 나는 이 팀 소속이에요! 
  - 팀이 주인: 이 멤버는 내 팀 소속이에요!

## 일대다 단방향(1:N)

```java
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    
    private String name;
    
    @OneToMany  // 일대다
    @JoinColumn(name = "team_id")  // Member 테이블의 FK
    private List<Member> members = new ArrayList<>();
    
    // 멤버 추가 메서드
    public void addMember(Member member) {
        members.add(member);
    }
}

@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    
    private String username;
    
    // Team을 모름 (단방향)
}
```

- Team -> Member 로만 접근이 가능하다.

<br/>

## 일대다 단방향 매핑의 단점

- '일'이 '다'를 관리하는 것이기 때문에.. 관리가 어렵고 성능 차이도 있다.

<br/>

- ex) 특정 팀에 멤버를 추가하고자 한다.
- 일대다의 경우
  1. 팀 저장
  2. 멤버 저장
  3. 팀에 멤버 추가(member의 team_id는 null임)
  4. 그 멤버의 team_id를 나중에 UPDATE 해줘야 함(쿼리가 추가로 발생)

- 다대일의 경우
  1. 팀 저장
  2. 멤버 팀 설정
  3. 멤버 저장

<br/>

## 일대다 양방향(1:N, N:1)

- 공식적으로는 존재하지 않는다.
- 양방향에서 일대다는 절대로 주인이 될 수 없다.
- 이는 위에서 설명한 것처럼 다대일에서 FK를 가지고 있는 '다'쪽이 주인이 되어야 하기 때문이다.
- 따라서 @ManyToOne을 사용한 곳이 무조건 주인이 된다.
- @ManyToOne 에서 mappedBy 속성을 사용할 수 없는 이유이기도 하다.

<br/>

- 굳이 일대다 양방향을 표현하자면('일'쪽을 주인으로 설정하자면)... 다음과 같다.

```java
@Entity
public class Team {
    @Id @GeneratedValue
    private Long id;
    
    @OneToMany
    @JoinColumn(name = "team_id")
    private List<Member> members = new ArrayList<>();
}

@Entity
public class Member {
    @Id @GeneratedValue
    private Long id;
    
    // 일대다 양방향을 위한 편법
    @ManyToOne
    @JoinColumn(name = "team_id", insertable = false, updatable = false)
    private Team team;    // 읽기 전용
}
```

- 본인 피셜 쓸 이유도 없고 이해할 필요도 없다고 생각한다.

<br/><br/>

# 6.3 일대일(1:1)

- 양쪽이 서로 하나의 관계만 가짐
- 회원 -> 사물함 관계
- 다대일과 다르게 양쪽 테이블 모두 외래키를 가질 수 있음!

## 주 테이블에 외래 키

- 객체지향 개발자들이 선호하는 방식이라고 한다.
- JPA도 이 경우를 더 편리하게 매칭해주는 듯
  
### 단방향
```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id;
    
    private String username;

    @OneToOne
    @JoinColumn(name = "locker_id")  // FK
    private Locker locker;            // 사물함
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "locker_id")
    private Long id;
    
    private String name;
}
```

- Locker는 누가 자신을 사용하는지 모름(Member 모름).
  
### 양방향

```java
@Entity
public class Member {
    @Id @GeneratedValue
    @Column(name = "member_id")
    private Long id;
    
    private String username;

    @OneToOne
    @JoinColumn(name = "locker_id")  // FK
    private Locker locker;            // 사물함
}

@Entity
public class Locker {
    @Id @GeneratedValue
    @Column(name = "locker_id")
    private Long id;
    
    private String name;

    @OneToOne(mappedBy = "locker")
    private Member member;
}
```

- 학생은 자기 사물함을 알 수 있고
- 사물함도 자기를 사용하는 학생을 알 수 있음

<br/>

## 대상 테이블에 외래 키

### 단방향

- 단방향은 기본적으로 불가능하다.
- JPA는 외래 키를 가진 쪽을 연관관계의 주인으로 삼아야 함
- 하지만 주 테이블에 먼저 데이터를 INSERT해야 하는 경우, FK가 종속적인 엔티티에 있으면 순환 참조 문제가 발생할 수 있음.
- 즉, JPA가 객체 그래프를 탐색할 때 연관관계의 주인을 통해서만 관계를 관리하는데, 대상 테이블이 주인이 되면 주 테이블이 이를 인식하지 못해 데이터 정합성 문제가 생길 수 있음.


### 양방향

```java

```

<br/><br/>

# 6.4 다대다(N:N)

## 단방향

<br/>

## 양방향

<br/>

## 한계와 극복, 연결 엔티티 사용

<br/>

## 새로운 기본 키 사용

