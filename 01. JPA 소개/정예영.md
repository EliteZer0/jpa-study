# 01. JPA 소개

## 1-1 SQL을 직접 다룰 때 발생하는 문제점

자바로 작성한 애플리케이션은 JDBC(Java Database Connectivity) API를 사용해 SQL을 데이터베이스에 전달한다.

- 진정한 의미의 계층 분할이 어렵다.
  - 개발자가 DAO를 열어 어떤 SQL이 실행되고, 어떤 객체들이 함께 조회되는지 확인해야 한다.
- 엔티티를 신뢰할 수 없다.
- SQL 의존적인 개발을 피하기 어렵다.

### JPA를 통한 해결법

- **저장 기능**  
  `persist()` 메소드를 통해 객체를 데이터베이스에 저장한다. 이 메소드를 호출하면 JPA가 객체와 매핑 정보를 보고 적절한 INSERT SQL을 생성해 데이터베이스에 전달한다.

- **조회 기능**  
  `find()` 메소드를 통해 객체와 매핑 정보를 보고 적절한 SELECT SQL을 생성해 데이터베이스에 전달하며, 조회 결과로 객체를 반환한다.

- **수정 기능**  
  JPA는 별도의 수정 메소드를 제공하지 않는다. 대신 객체를 조회해 값을 변경하면 트랜잭션을 커밋할 때 UPDATE SQL이 전달된다.

- **연관된 객체 조회**  
  JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행한다. 이를 통해 연관된 객체를 손쉽게 조회할 수 있다.

---

## 1-2 패러다임 불일치

객체는 속성(필드)과 기능(메소드)을 가지며, 상속, 참조 등 복잡한 구조를 가질 수 있다. 반면 관계형 데이터베이스는 데이터 중심으로 구조화되어 있고, 집합적인 사고를 요구하며, 추상화, 상속, 다형성 같은 개념이 없다. 이러한 차이를 *객체와 관계형 데이터베이스의 패러다임 불일치*라고 한다.

### 상속

- 객체는 상속이라는 기능을 가지고 있지만, 테이블에는 상속이라는 개념이 없다.
- 슈퍼타입/서브타입 관계를 사용해 테이블 설계를 해야 한다.
- JDBC API로 구현하려면 부모와 자식 데이터를 각각 INSERT SQL로 작성하고, 조회 시에도 조인을 사용해야 한다.

### 연관관계

- 객체는 참조를 통해 연관관계를 가지며 참조 방향으로만 탐색이 가능하다.
- 테이블은 외래 키(Foreign Key)를 통해 양방향 탐색이 가능하다.
- 객체 모델링을 테이블 구조에 맞추면 좋은 객체 모델링을 기대하기 어렵다.

#### 저장
객체를 저장하려면 외래 키 값을 찾아 INSERT SQL을 만들어야 한다.

#### 조회
조회 시 외래 키 값을 변환해 객체에 보관해야 한다. 컬렉션에 연관된 객체를 저장하려면 추가 비용이 발생한다.

#### JPA와 연관관계
JPA는 연관관계와 관련된 패러다임 불일치 문제를 해결한다. 관계 설정 후 객체를 저장하면 JPA가 참조를 외래 키로 변환해 적절한 INSERT SQL을 생성하고, 조회 시에는 외래 키를 참조로 변환한다.

### 객체 그래프 탐색

#### 정의
객체에서 참조를 사용해 연관된 객체를 탐색하는 것을 의미한다.

#### JPA에서의 처리
JPA는 연관된 객체를 사용하는 시점에 적절한 SELECT SQL을 실행하므로 자유롭게 객체 그래프 탐색이 가능하다.

### 비교

데이터베이스는 기본 키 값으로 각 row를 구분하지만, 객체는 동일성 비교와 동등성 비교 두 가지 방법을 제공한다.

- **동일성 비교**: `==` 연산자로 주소 값을 비교한다.
- **동등성 비교**: `equals()` 메소드를 사용해 내부 값을 비교한다.

JPA는 같은 트랜잭션 내에서 동일한 row 데이터를 동일한 객체로 관리하므로 동일성 비교에서도 성공할 수 있다.

### 정리
객체 모델과 관계형 데이터베이스 모델의 패러다임 불일치 문제는 정교한 객체 모델링을 방해하며 개발 비용을 증가시킨다. 이를 해결하기 위해 등장한 기술이 바로 JPA이다.

---

## 1-3 JPA란 무엇인가

JPA(Java Persistence API)는 자바 진영의 ORM(Object-Relational Mapping) 기술 표준이다. 어플리케이션과 JDBC 사이에서 동작하며, 패러다임 불일치 문제를 해결하는 데 도움을 준다. 대표적인 구현체로 하이버네이트가 있다.

### JPA의 역사
과거 엔터프라이즈 자바 빈즈(EJB) 기술 표준에서 ORM 기술인 엔티티 빈(Entity Bean)이 포함되었지만 복잡성과 성숙도 부족으로 인해 널리 사용되지 못했다. 이후 하이버네이트가 등장하면서 가볍고 실용적인 ORM 프레임워크가 대중화되었고, 이를 기반으로 자바 진영은 새로운 ORM 기술 표준인 JPA를 만들었다.

### 왜 JPA를 사용해야 하는가

- **생산성**: 자바 컬렉션에 저장하듯이 간단하게 데이터를 저장할 수 있다.
- **유지보수**: 엔티티 필드 추가/삭제 시에도 SQL과 JDBC 코드를 수정할 필요가 없어 유지보수성이 높아진다.
- **패러다임 불일치 해결**: 상속, 연관관계, 객체 그래프 탐색 등 다양한 문제 해결.
- **성능 최적화**: 1차 캐시와 지연 로딩 등 다양한 최적화 기법 제공.
- **데이터 접근 추상화 및 벤더 독립성**: 특정 데이터베이스 기술에 종속되지 않도록 설계 가능.
- **표준 기술**: JPA 표준 덕분에 다른 구현체로 손쉽게 변경 가능하다.

---

## Q&A

### Q: ORM 프레임워크를 사용하면 SQL과 데이터베이스 지식이 필요 없는가?
아니다. ORM은 데이터를 관계형 데이터베이스에 저장하므로 테이블 설계와 SQL 지식은 여전히 중요하다. ORM은 단순히 매핑 작업을 도와줄 뿐이다.

### Q: 성능 문제가 발생하지 않는가?
JPA는 다양한 성능 최적화 기능을 제공하므로 잘 사용하면 오히려 더 나은 성능을 낼 수 있다. 하지만 잘못된 사용으로 N+1 문제 등이 발생할 수 있으니 학습이 중요하다.

### Q: 복잡한 통계 쿼리는 어떻게 처리하는가?
JPA는 복잡한 통계 쿼리보다는 실시간 처리용 쿼리에 더 적합하다. 복잡한 통계 쿼리는 네이티브 SQL이나 다른 SQL 매퍼 프레임워크(예: 마이바티스)를 혼용해 사용하는 것이 좋다.

### Q: 마이바티스와 어떤 차이가 있는가?
마이바티스는 SQL 매퍼로, 개발자가 직접 작성한 SQL과 매핑 작업만 지원한다. 반면 JPA는 ORM으로, 테이블과 객체 간 매핑만 설정하면 프레임워크가 필요한 SQL을 자동 생성하고 실행까지 처리한다.

### Q: 학습곡선이 높지 않은가?
JPA는 학습곡선이 높은 편이다. 특히 영속성 컨텍스트 등 핵심 개념 이해가 필수적이다. 기초 없이 사용하면 오히려 비효율적일 수 있다.