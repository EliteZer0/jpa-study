# JPQL

- 객체 지향 쿼리 언어
    - 엔티티를 대상으로 쿼리
    - SQL을 추상화해서 특정 DB SQL에 의존 X
    - JPQL은 결국 SQL로 변환됨

- 기본 문법
    - select, update, delete 문 사용
        - insert는 EntityManager.persist()로
    - 엔티티 속성(ex: Member, username) 은 대소문자 구분
    - JPQL 키워드(ex: select, from ,as) 는 대소문자 구분 X
    - 엔티티명을 활용해 쿼리
        - 엔티티명을 지정하지 않으면 클래스명을 기본 값으로
    - 별칭(as)를 필수로 사용해야 함
        - 안쓰면 오류
        - as 키워드를 꼭 쓰진 않아도 됨

- TypeQuery, Query
    - TypeQuery : 반환할 타입을 명확하게 지정할 수 있을 때
        
        ```java
        TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);
        
        List<Member> resultList = query.getResultList();
        for(Member member : resultList) {
        	System.out.println("member = " + member);
        }
        ```
        
    - Query : 반환 타입을 명확하게 지정할 수 없을 때
        
        ```java
        Query query = em.createQuery("SELECT m.username, m.age from Member m");
        List resultList = query.getResultList();
        
        for(Object o : resultList) {
        	Object[] result = (Object[]) o; //결과가 둘 이상이면 Object[] 반환
        	System.out.println("username = " + result[0]);
        	System.out.println("age = " + result[1]);
        }
        ```
        
    - 결과 조회
        - query.getResultList
            - 결과가 없으면 빈 컬렉션
        - query.getSingleResult
            - 결과가 정확히 하나일 때
            - 결과가 없거나 2개 이상이면 예외 발생

- 파라미터 바인딩
    - 이름 기준 파라미터
        - 파라미터를 이름으로 구분
        - 앞에 : 를 사용
        
        ```java
        String usernameParam = "User1";
        
        TypedQuery<Member> query = 
        	em.createQuery("SELECT m FROM Member m where m.uername = :username",
        		Member.class)
        		.setParameter("username", usernameParam)
        		.getResultList();
        
        // 메소드 체인 방식 안쓸 때
        // query.setParameter("username", usernameParam);
        // List<Member> resultList = query.getResultList();
        ```
        
    - 위치 기준 파라미터
        - ? 다음에 위치값을 줌
        
        ```java
        List<Member> members =
        	em.createQuery("SELECT m FROM Mebmer m where m.username = ?1",
        	Member.class)
        	.setParameter(1, usernameParam)
        	.getResultList();
        ```
        
    
    <aside>
    💡
    
    이름 기준 파라미터 바인딩을 사용하는 것이 명확
    
    </aside>
    
    - JDBC : 위치 기준 파라미터 바인딩만 지원
    - **JPQL : 이름 기준 파라미터 바인딩도 지원**
    

### 프로젝션

- Select 절에 조회할 대상을 지정하는 것
- select {프로젝션 대상} from 으로 대상을 선택
    - 프로젝션 대상 : 엔티티, 임베디드 타입, 스칼라
        - 엔티티
            - 조회한 엔티티는 영속성 컨텍스트에서 관리
            - ex) select m.team from Member m
        - 임베디드 타입
            - 영속성 컨텍스트에서 관리 X
                - 임베디드 타입은 값 타입이기 때문에 (엔티티 타입 X)
            - 조회의 시작점이 될 수 없음
                - ex) Address가 임베디드 타입일 때
                - “select a from Address a” (X)
                - “select o.address from Order o” (O)
        - 스칼라 타입
            - 숫자, 문자, 날짜 등 기본 데이터 타입
        - 여러 값 조회
            - 필요한 데이터만 선택해서 조회
            - Object[]를 활용한 여러 프로젝션 조회
                - 실제 개발 시에는 이 방법보다 DTO 처럼 의미 있는 객체로 변환해서 사용
                
                ```java
                List<Object[]> resultList =
                	em.createQuery("SELECT m.username, m.age FROM Member m")
                	.getResultList();
                	
                for (Object[] row : resultList) {
                	String username = (String) row[0];
                	Integer age = (Integer) row[1];
                }
                ```
                
                ```java
                // 엔티티 타입 조회
                List<Object[]> resultList =
                	em.createQuery("SELECT o.member, o.product, o.orderAmount FROM Order o")
                		.getResultList();
                	
                for (Object[] row : resultList) {
                	Member member = (Member) row[0]; // 엔티티
                	Product product = (Product) row[1]; // 엔티티
                	int orderAmount = (Integer) row[2]; // 스칼라
                }
                	
                ```
                
        
        - NEW 명령어
            - 패키지 명을 포함한 전체 클래스 명을 입력
            - 순서와 타입이 일치하는 생성자가 필요
            
            ```java
            TypedQuery<UserDTO> query  = em.createQuery("SELECT new jpabook.jpql.UserDTO(m.username, m.age
            		FROM Member m", UserDTO.class);
            		
            List<UserDTO> resultList = query.getResultList();
            ```
